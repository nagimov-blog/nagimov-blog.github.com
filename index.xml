<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>the daily meh on the daily meh</title><link>https://nagimov.me/</link><description>Recent content in the daily meh on the daily meh</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 03 Oct 2019 19:41:14 -0700</lastBuildDate><atom:link href="/" rel="self" type="application/rss+xml"/><item><title>The Horror of PLC programming</title><link>https://nagimov.me/post/the-horror-of-plc-programming/</link><pubDate>Thu, 03 Oct 2019 19:41:14 -0700</pubDate><guid>https://nagimov.me/post/the-horror-of-plc-programming/</guid><description>
&lt;p&gt;Consider this simple code snippet&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 VALVE1_POS = S405_VH(1400)
20 VALVE2_POS = 80.0
30 IF VALVE1_POS &amp;gt; 50.0 THEN VALVE3_POS = 99.5 ELSE VALVE3_POS = 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;hellip;and let me follow your observations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you notice a weird line enumeration, just like in good old BASIC&lt;/li&gt;
&lt;li&gt;you see three variables, &lt;code&gt;VALVE1_POS&lt;/code&gt;, &lt;code&gt;VALVE2_POS&lt;/code&gt; and &lt;code&gt;VALVE3_POS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;you find &lt;code&gt;S405_VH(1400)&lt;/code&gt; most likely to be a function call retrieving a position of the valve 1&lt;/li&gt;
&lt;li&gt;position of the valve 2 is set to &lt;code&gt;80.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;following the last if-then-else statement, you realize that the valve 3 position is defined based on the valve 1 position&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Can you now guess what values &lt;code&gt;VALVE1_POS&lt;/code&gt;, &lt;code&gt;VALVE2_POS&lt;/code&gt; and &lt;code&gt;VALVE3_POS&lt;/code&gt; would store after the above code is executed? Make you wildest assumptions about how this code can misbehave. Ready? Check your answers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VALVE1_POS&lt;/code&gt; is &lt;code&gt;99.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VALVE2_POS&lt;/code&gt; is &lt;code&gt;99.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VALVE3_POS&lt;/code&gt; is &lt;code&gt;99.5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Weird. Okay, here&amp;rsquo;s another simple two-liner:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 VALVE1_POS_STEP = 10.0
20 VALVE1_POS_END = 90.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two variables, two assignments, what can go wrong? There is simply no way for this code to misbehave. And yet it does, spectacularly. In fact, both lines contain invalid statements.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s dig into these simple examples and uncover The Horror of PLC Programming.&lt;/p&gt;
&lt;h3 id=&#34;why-basic&#34;&gt;Why BASIC?&lt;/h3&gt;
&lt;p&gt;Let me give you a little background so you feel a bit more comfortable in our journey to the world of PLCs, aka Programming Logic Controllers.&lt;/p&gt;
&lt;p&gt;The code you see is indeed written in a limited and slightly deformed subset of BASIC. You may or may not find the lack of &lt;code&gt;LET&lt;/code&gt;&amp;rsquo;s to be awkward, but otherwise these snippets are plain and simple BASIC. There are no arrays with their &lt;code&gt;DIM&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;REDIM&lt;/code&gt;&amp;rsquo;s to screw things up or &lt;a href=&#34;https://stackoverflow.com/questions/18135971/quick-basic-colon-line-separator&#34;&gt;colon controversies&lt;/a&gt;. It&amp;rsquo;s as basic as BASIC gets (sorry).&lt;/p&gt;
&lt;p&gt;&amp;ldquo;What a weird language choice for controlling valves!&amp;rdquo; you say. &amp;ldquo;What on flat-earth does this have to deal with 2019?&amp;rdquo; you ask. Keep on reading.&lt;/p&gt;
&lt;p&gt;PLCs are made to be robust and programmed using &lt;a href=&#34;https://en.wikipedia.org/wiki/Ladder_logic&#34;&gt;ladder logic&lt;/a&gt;. PLC programs are not meant to be easy to write, but are easy to debug. You&amp;rsquo;ll never find tail-recursion or polymorphism capabilities in PLC languages. There is no unit-testing, you&amp;rsquo;ll test it in the field, attached to a big, heavy, piece of industrial machinery. Many of PLCs lack the most basic concepts like &lt;em&gt;variables&lt;/em&gt;. Ladder logic is never mentioned at hackathons, your local meetups, or praised on hacker news.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hn.algolia.com/?query=%22ladder%20logic%22&#34;&gt;&lt;img src=&#34;https://nagimov.me/images/ladder-logic-hacker-news.png#center&#34; alt=&#34;width500px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Programmable_logic_controller#Invention_and_early_development&#34;&gt;As a natural evolution of electromechanical relay control systems&lt;/a&gt;, ladder logic programming follows similar rules. Here&amp;rsquo;s how a simple PLC program controlling AC unit might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. ----[ ]---------+----[ ]-----+----( )
Switch | HiTemp | A/C
| |
+----[ ]-----+
Humid
2. ----[ ]----[\]--------------------( )
A/C Heat Cooling
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inputs &amp;ldquo;relays&amp;rdquo; are shown as &lt;code&gt;--[ ]--&lt;/code&gt;, outputs are &lt;code&gt;--( )--&lt;/code&gt;. When enough input &amp;ldquo;relays&amp;rdquo; are activated to create a &amp;ldquo;current path&amp;rdquo; to the output, it becomes &amp;ldquo;energized&amp;rdquo;. This worked well for early systems that were designed to replace relay boxes. Spoiled engineers however kept asking for fancier features, such as integer arithmetic, floating-point operations and even string manipulations. Following the lead of a semiconductor industry, PLC manufacturers complemented their systems with fancy floating-point coprocessors. Unfortunately, most of them haven&amp;rsquo;t got further.&lt;/p&gt;
&lt;p&gt;Back to 2019, a current generation of mid-level PLCs from a well known North American manufacturer requires a coprocessor to interface with serial interfaces. This coprocessor is fancy enough to support floating point math and string manipulations and, you guessed it, is programmed in BASIC. Our happy PLC programmer is eager to use it to its full potential, multiply floats, truncate string and sometimes go crazy extracting square roots.&lt;/p&gt;
&lt;p&gt;So let&amp;rsquo;s get back to our first example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 VALVE1_POS = S405_VH(1400)
20 VALVE2_POS = 80.0
30 IF VALVE1_POS &amp;gt; 50.0 THEN VALVE3_POS = 99.5 ELSE VALVE3_POS = 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;the-call-of-mysterious-s405-vh&#34;&gt;The call of mysterious &lt;code&gt;S405_VH&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;I know what you&amp;rsquo;re thinking. The mysterious function that appears in the first example has some magical powers and is going to change the global state, hang the execution, or throw a weird uncatchable exception. This is not the case.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S405_VH(1400)&lt;/code&gt; simply reads an octal word from specified memory address &lt;code&gt;V1400&lt;/code&gt; in HEX format, hence &lt;code&gt;_VH&lt;/code&gt;. What is an octal word, you ask? Well, it&amp;rsquo;s just two 8-bit memory chunks stitched together, aka 16-bit. No, you can&amp;rsquo;t call it a &amp;ldquo;byte&amp;rdquo;. It&amp;rsquo;s an octal.&lt;/p&gt;
&lt;p&gt;Why memory is addressed in such a weird way, &lt;code&gt;V1400&lt;/code&gt;? There are two parts: &lt;code&gt;V&lt;/code&gt; indicates a type of memory range. Along with &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;CT&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;SP&lt;/code&gt;, &lt;code&gt;GX&lt;/code&gt; and &lt;code&gt;GY&lt;/code&gt;, it partitions the PLC memory into various &amp;ldquo;types&amp;rdquo;. Some types are inputs, some are outputs, some store timers and counters, some store system configuration parameters. They can store octal words (16&amp;nbsp;bit), single octals (8&amp;nbsp;bit), or deal with individual bits directly.&lt;/p&gt;
&lt;p&gt;The second part, &lt;code&gt;1400&lt;/code&gt;, is the address of a memory location within the &lt;code&gt;V&lt;/code&gt;&amp;nbsp;memory type range. Since &lt;code&gt;1400&lt;/code&gt; is an octal number, you would write it as &lt;code&gt;01400&lt;/code&gt; in C, or &lt;code&gt;0o1400&lt;/code&gt; in Python, but it&amp;rsquo;s just the semantics of this particular PLC. Everything is an octal. This particular value, &lt;code&gt;0o1400&lt;/code&gt; is the beginning of a specialized sub-range of the &lt;code&gt;V&lt;/code&gt;&amp;nbsp;memory type that spans from &lt;code&gt;0o1400&lt;/code&gt; to &lt;code&gt;0o7377&lt;/code&gt;, it is a so called &amp;ldquo;User Data Types&amp;rdquo; range. &lt;code&gt;V&lt;/code&gt;&amp;nbsp;memory ranges start at &lt;code&gt;0o700&lt;/code&gt;, not &lt;code&gt;0o0&lt;/code&gt; (remember typing &lt;code&gt;org 0x100&lt;/code&gt; in x86 assembly, like, 30 years ago?). There are no variables, only an &amp;ldquo;accumulator&amp;rdquo;. Data management hasn&amp;rsquo;t improved much since &lt;code&gt;mov ax, dx&lt;/code&gt;. The point being that &lt;strong&gt;BASIC is a step ahead&lt;/strong&gt; from native PLC code.&lt;/p&gt;
&lt;p&gt;(You remember I said that everything is an octal? I lied. When you deal with data, then everything is HEX. Unless it&amp;rsquo;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary-coded_decimal&#34;&gt;binary-coded decimal (BCD)&lt;/a&gt;, sometimes. If that&amp;rsquo;s the case, it is programmer&amp;rsquo;s responsibility to ensure that BCD-HEX conversions are handled properly, compile time checks don&amp;rsquo;t catch that.)&lt;/p&gt;
&lt;h3 id=&#34;what-s-wrong-with-the-valves&#34;&gt;What&amp;rsquo;s wrong with the valves&lt;/h3&gt;
&lt;p&gt;But I digress. We are trying to understand the first line of the first example, &lt;code&gt;VALVE1_POS = S405_VH(1400)&lt;/code&gt;. &amp;ldquo;I know!&amp;rdquo; you say. &amp;ldquo;It returns HEX instead of BCD! Or BCD instead of HEX! Or an integer instead of a float! That&amp;rsquo;s where the bug is!&amp;rdquo; But that would be too easy. So let&amp;rsquo;s assume that &lt;code&gt;S405_VH(1400)&lt;/code&gt; returns exactly what we expect and the variable &lt;code&gt;VALVE1_POS&lt;/code&gt; now contains a legitimate value. And yet, after all three lines are executed, &lt;code&gt;VALVE1_POS&lt;/code&gt;, &lt;code&gt;VALVE2_POS&lt;/code&gt; and &lt;code&gt;VALVE3_POS&lt;/code&gt; all contain value &lt;code&gt;99.5&lt;/code&gt;. In fact they are all &lt;strong&gt;the same variable&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s how this particular implementation of BASIC identifies variables by their names:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get the first character of the variable name (A);&lt;/li&gt;
&lt;li&gt;get the last character of the variable name (B);&lt;/li&gt;
&lt;li&gt;get the length of the variable name (N);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique combination of A, B and N defines a variable&lt;/strong&gt;, so &lt;code&gt;VALVE1_POS&lt;/code&gt;, &lt;code&gt;VALVE2_POS&lt;/code&gt; and &lt;code&gt;VALVE3_POS&lt;/code&gt; are interpreted as identical names.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imagine the world where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TEMP1_C&lt;/code&gt; and &lt;code&gt;TEMP2_C&lt;/code&gt; are identical variables;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIMER_RST_1&lt;/code&gt; and &lt;code&gt;TIMER_ACC_1&lt;/code&gt; are identical variables;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRESSURE_GAGE&lt;/code&gt;, &lt;code&gt;PRESSURE_TUBE&lt;/code&gt; and &lt;code&gt;PRESSURE_PIPE&lt;/code&gt; are all the same thing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happy debugging.&lt;/p&gt;
&lt;h3 id=&#34;two-bugs-in-two-lines&#34;&gt;Two bugs in two lines&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;10 VALVE1_POS_STEP = 10.0
20 VALVE1_POS_END = 90.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example is similarly annoying. In this particular BASIC world, variables cannot contain any keywords as a part of their names.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STEP&lt;/code&gt; is a keyword. &lt;code&gt;END&lt;/code&gt; is a keyword. &lt;code&gt;VALVE1_POS_STEP&lt;/code&gt; and &lt;code&gt;VALVE_RAMP_END&lt;/code&gt; aren&amp;rsquo;t valid variable names.&lt;/p&gt;
&lt;h3 id=&#34;docu-mentation&#34;&gt;Docu&amp;hellip; mentation?&lt;/h3&gt;
&lt;p&gt;The fun way of discovering these &amp;ldquo;features&amp;rdquo; is of course through endless debugging (there is no actual debugger, you just print your variables to a serial port and catch them at the other end). Okay, let&amp;rsquo;s assume you&amp;rsquo;re keen to RTFM and download manuals from manufacturer&amp;rsquo;s web-site. Unfortunately, they don&amp;rsquo;t contain language specifications. You&amp;rsquo;re not giving up and going through manuals for similar and discontinued modules. One of them describes this behavior as a &amp;ldquo;helpful hint&amp;rdquo; [sic] at the end of a code sample, in the &amp;ldquo;TRANSFER INSTRUCTION&amp;rdquo; chapter of the manual:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Helpful Hint: The variables LSB10 and LSB20, CODE15 and CODE25 or REG400 and REG410 will return the same value due to the way that BASIC stores variables. To avoid this problem, use dimensioned variables such as CODE(index) or REG(index).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;No wonder you missed that. So you keep debugging. Your programming tool doesn&amp;rsquo;t show any useful messages so you give up trying to google the problem. Days go by, and you make no progress. Desperate, you are seeking for advice. You are knocking at the door of &amp;ldquo;Bob the PLC guy&amp;rdquo; who is retiring in two days. You&amp;rsquo;re hiding your tears and trying to stay calm. He looks at your code and smiles, pulls up an old IBM Thinkpad with Windows&amp;nbsp;2000 and launches a weird looking version of the programming tool. He then presses &lt;code&gt;F1&lt;/code&gt; and Microsoft Windows Help shows up. He types &amp;ldquo;variables&amp;rdquo; in the search bar and finds the page he needs. You look at the page, and you look at the guy. You&amp;rsquo;re angry and happy at the same time. You copy the &lt;code&gt;*.hlp&lt;/code&gt; file and thank Bob. You leave early that day and head to your favorite bar to have a little celebration. You are now a &amp;ldquo;Level 2 PLC guy&amp;rdquo;.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;all-characters-and-other-entities-appearing-in-this-story-are-fictitious-any-resemblance-to-real-persons-dead-or-alive-or-other-real-life-entities-past-or-present-is-purely-coincidental&#34;&gt;&lt;em&gt;All characters and other entities appearing in this story are fictitious. Any resemblance to real persons, dead or alive, or other real-life entities, past or present, is purely coincidental.&lt;/em&gt;&lt;/h4&gt;</description></item><item><title>Running docker on 32-bit hosts</title><link>https://nagimov.me/post/running-docker-on-32-bit-hosts/</link><pubDate>Sun, 03 Feb 2019 00:42:28 -0800</pubDate><guid>https://nagimov.me/post/running-docker-on-32-bit-hosts/</guid><description>
&lt;p&gt;Docker is known to not to support 32-bit hosts. As per their &lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian&#34;&gt;debian installation instruction&lt;/a&gt;: &lt;code&gt;Docker CE is supported on x86_64 (or amd64), armhf, and arm64 architectures.&lt;/code&gt; And that is plain wrong.&lt;/p&gt;
&lt;p&gt;A tiny bit of extra support from docker-the-company would extend its use to older hardware, but (apparently) this is not a priority. &amp;ldquo;Let&amp;rsquo;s bring docker on 32-bit&amp;rdquo; &lt;a href=&#34;https://github.com/moby/moby/issues/136&#34;&gt;issue&lt;/a&gt; was closed and locked in 2014, and nothing has changed since then.&lt;/p&gt;
&lt;p&gt;Nothing fundamentally prevents docker (including latest version of docker CE) from being run on 32-bit platforms (except the lack of support from docker-the-company, of course). I&amp;rsquo;m currently running (a bit outdated) version &lt;code&gt;18.03.0-ce&lt;/code&gt; of docker on 15 years old &lt;a href=&#34;https://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=AN&amp;amp;subtype=CA&amp;amp;htmlfid=897/ENUS104-011&#34;&gt;IBM xSeries 335 server&lt;/a&gt; with whopping 2.8GHz Intel Xeon and 4GB of DDR RAM (just for the sake of it, of course). That&amp;rsquo;s enough to run half a dozen containers (nginx proxy with simple API end points) and a bunch of scripts poking at various sensors via &lt;a href=&#34;https://labjack.com/&#34;&gt;LabJack IO board&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nagimov.me/images/ibm-xseries-335.jpg#center&#34; alt=&#34;width500px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The server only supports IDE drives and I had to use a floppy diskette to sideload firmware for the network card (USB port wasn&amp;rsquo;t recognized by debian installer). This particular server been in &lt;sup&gt;24&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7&lt;/sub&gt; operation since its birth, with a brief interruption for two years in 2013-2014, when its ownership has changed (yeah, I picked it from the scrap yard). I have two complete replacement spares and I don&amp;rsquo;t care about electricity bill, so it&amp;rsquo;s good enough piece of hardware for some lightweight business. Also check out its early 2000&amp;rsquo;s boot animation (how can one simply retire such a fine piece of equipment?!):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nagimov.me/images/ibm-xseries-335-boot-diskette.gif#center&#34; alt=&#34;width300px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There are obviously no official docker builds for 32-bit platforms, but &lt;a href=&#34;https://github.com/mforkel/docker-ce-i386&#34;&gt;this fork&lt;/a&gt; adds support for building docker CE for i386. It is slightly outdated (&lt;code&gt;18.03.0-ce&lt;/code&gt; as of February 2019), albeit I can&amp;rsquo;t remember any sweet features released since then anyways (yet).&lt;/p&gt;
&lt;p&gt;The build scripts are x64 platform oriented, so if you can build docker on 64-bit platform first, the recipe should work as-is.&lt;/p&gt;
&lt;p&gt;I decided to challenge myself and try to run the whole installation using only 32-bit server, so there were few changes required to complete the build.&lt;/p&gt;
&lt;h4 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;debian 9.5.0 32-bit installed&lt;/li&gt;
&lt;li&gt;apt repositories configured to use internet connection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; and &lt;code&gt;build-essential&lt;/code&gt; installed in addition to bare debian image&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;installing-docker-io&#34;&gt;Installing &lt;code&gt;docker-io&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The above mentioned build scripts for docker make use of existing docker installation. So if we want to build docker for 32-bit platform, we have to have docker installed (&lt;code&gt;WinRAR.rar&lt;/code&gt;, anyone?)&lt;/p&gt;
&lt;p&gt;As hopeless as it sounds, there is a way out. &lt;code&gt;Docker.io&lt;/code&gt; package from &lt;code&gt;jessie-backports&lt;/code&gt; is actually &lt;em&gt;runnable&lt;/em&gt; on 32-bit, even though there is a big red flag in the &lt;a href=&#34;https://packages.debian.org/jessie-backports/docker.io&#34;&gt;description&lt;/a&gt;: &lt;code&gt;Using docker.io on non-amd64 hosts is not supported at this time. Please be careful when using it on anything besides amd64.&lt;/code&gt; We are not going to use &lt;code&gt;docker.io&lt;/code&gt; in production, and it works fine as a simple build environment.&lt;/p&gt;
&lt;p&gt;Install the package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add &lt;code&gt;deb https://deb.debian.org/debian jessie-backports main&lt;/code&gt; to your apt sources in &lt;code&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;update package index: &lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;install the package: &lt;code&gt;sudo apt-get -t jessie-backports install docker.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check the version of docker binary: &lt;code&gt;docker -v&lt;/code&gt; (outputs &lt;code&gt;Docker version 1.6.2, build 7c8fca2&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;building-docker-from-sources&#34;&gt;Building docker from sources&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s then get to it and build (relatively) fresh docker from &lt;a href=&#34;https://github.com/mforkel/docker-ce-i386&#34;&gt;this magic repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Clone the repo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd /tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/mforkel/docker-ce-i386&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd docker-ce-i386&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depending from the current state of this github repository, you might have to switch to the proper branch, e.g. &lt;code&gt;git checkout 18.03-i386&lt;/code&gt;, depending from which versions are available. I&amp;rsquo;ll be fixing this build to the latest commit available as of February, 2019, so it&amp;rsquo;s reproducible:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git checkout c68b084&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Again, the build script assumes that you have relatively fresh version of docker installed already. Our &lt;code&gt;docker.io&lt;/code&gt; is from 2015, and it doesn&amp;rsquo;t support &lt;code&gt;ARG&lt;/code&gt; parameter of Dockerfiles. We need to get rid of it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/ARG APT_MIRROR=deb.debian.org/# ARG APT_MIRROR=deb.debian.org/&amp;quot; ./components/engine/contrib/builder/deb/i386/debian-stretch/Dockerfile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/\$APT_MIRROR/deb.debian.org/&amp;quot; ./components/engine/contrib/builder/deb/i386/debian-stretch/Dockerfile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/ARG APT_MIRROR=deb.debian.org/# ARG APT_MIRROR=deb.debian.org/&amp;quot; ./components/packaging/deb/debian-stretch/Dockerfile.i386&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/\$APT_MIRROR/deb.debian.org/g&amp;quot; ./components/packaging/deb/debian-stretch/Dockerfile.i386&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The build script also makes use of the official &lt;code&gt;alpine&lt;/code&gt; image from dockerhub, that is 64-bit. It has to be replaced with &lt;code&gt;i386/alpine&lt;/code&gt; image:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/alpine/i386\/alpine/&amp;quot; ./components/packaging/deb/Makefile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now it&amp;rsquo;s finally time to run the build (be patient):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo ARCH=i386 DOCKER_BUILD_PKGS=debian-stretch make deb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Make sure that newly built &lt;code&gt;*.deb&lt;/code&gt; package is there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls ./components/packaging/deb/debbuild/debian-stretch/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove old docker installation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get remove docker.io&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Install newly built &lt;code&gt;*.deb&lt;/code&gt; package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo dpkg -i ./components/packaging/deb/debbuild/debian-stretch/docker-ce_18.03.0~ce-0~debian_i386.deb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install -f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And we&amp;rsquo;re done:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker -v&lt;/code&gt; (outputs &lt;code&gt;Docker version 18.03.0-ce, build c68b084381&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo docker run hello-world&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;getting-32-bit-docker-compose&#34;&gt;Getting 32-bit docker-compose&lt;/h4&gt;
&lt;p&gt;This one is much easier, since i386 package of &lt;code&gt;docker-compose&lt;/code&gt; is available from &lt;a href=&#34;https://launchpad.net/ubuntu/xenial/i386/docker-compose/1.8.0-2~16.04.1&#34;&gt;this&lt;/a&gt; Ubuntu Xenial repository, so installation is as simple as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd /tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wget https://launchpadlibrarian.net/314562376/docker-compose_1.8.0-2~16.04.1_all.deb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo dpkg -i docker-compose_1.8.0-2~16.04.1_all.deb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install -f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose --version&lt;/code&gt; (outputs &lt;code&gt;docker-compose version 1.8.0, build unknown&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;living-with-docker-on-32-bit&#34;&gt;Living with docker on 32-bit&lt;/h4&gt;
&lt;p&gt;Bear in mind, this is not the end of the journey. Most of the available images are built using 64-bit binaries (see the above mentioned official &lt;code&gt;alpine&lt;/code&gt; image), so there will be issues. E.g., the very popular &lt;a href=&#34;https://github.com/jwilder/nginx-proxy&#34;&gt;nginx-proxy&lt;/a&gt; uses 64-bit builds of both &lt;a href=&#34;https://github.com/jwilder/docker-gen&#34;&gt;docker-gen&lt;/a&gt; and &lt;a href=&#34;https://github.com/jwilder/forego&#34;&gt;forego&lt;/a&gt;, and based on official &lt;code&gt;nginx:1.11.10&lt;/code&gt; image (based on official &lt;code&gt;debian:jessie&lt;/code&gt; x64), so the corresponding changes are required:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i386 builds of docker-gen are available from &lt;a href=&#34;https://github.com/jwilder/docker-gen/releases&#34;&gt;releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;i386 build of forego can be found &lt;a href=&#34;https://dl.equinox.io/ddollar/forego/stable/archive&#34;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;bump nginx version to &lt;code&gt;nginx:1.14&lt;/code&gt; - it&amp;rsquo;s built from &lt;code&gt;debian:stretch-slim&lt;/code&gt; x32&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another example - must-have sibling of nginx-proxy, &lt;a href=&#34;https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion&#34;&gt;letsencrypt-nginx-proxy-companion&lt;/a&gt;, based on official &lt;code&gt;alpine&lt;/code&gt; image x64 and uses &lt;a href=&#34;https://github.com/jwilder/docker-gen&#34;&gt;docker-gen&lt;/a&gt; as well, therefore:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replace &lt;code&gt;alpine&lt;/code&gt; with &lt;code&gt;i386/alpine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace &lt;code&gt;docker-gen&lt;/code&gt; with i386 build&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;hellip;and so on. Some images of course are just not worth porting back to 32-bit world, so usage of docker on 32-bit platforms is limited by simple images, but that&amp;rsquo;s 90% of all my use-cases anyways :)&lt;/p&gt;</description></item><item><title>alsa-utils&#39; arecord bug: lots of *.wav files, ignoring --duration parameter</title><link>https://nagimov.me/post/alsa-utils-arecord-bug-lots-of-wav-files-ignoring-duration-parameter/</link><pubDate>Thu, 18 Aug 2016 20:56:00 -0800</pubDate><guid>https://nagimov.me/post/alsa-utils-arecord-bug-lots-of-wav-files-ignoring-duration-parameter/</guid><description>&lt;p&gt;&lt;img src=&#34;https://nagimov.me/images/alsamixer.png#center&#34; alt=&#34;width500px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;While working on a small side project at work, I found that I can&amp;rsquo;t record sound using Raspberry Pi with external USB sound card after upgrading it to Raspbian Jessie. Symptoms look rather weird: &lt;code&gt;arecord&lt;/code&gt; doesn&amp;rsquo;t stop recording after a period of time specified by &lt;code&gt;--duration&lt;/code&gt; flag, but keeps running and writing garbage to files like &lt;code&gt;*-01.wav&lt;/code&gt;, &lt;code&gt;*-02.wav&lt;/code&gt; and so on. Google doesn&amp;rsquo;t really give any solution to this (except &lt;a href=&#34;http://superuser.com/questions/583826/recording-using-arecord-creates-thousands-of-files&#34;&gt;the recommendation&lt;/a&gt; of terminating &lt;code&gt;arecord&lt;/code&gt; using &lt;code&gt;killall -KILL arecord&lt;/code&gt; after certain period of time). USB microphones are &lt;a href=&#34;https://www.raspberrypi.org/forums/viewtopic.php?f=66&amp;amp;t=138722&#34;&gt;also affected&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Considering I have another Raspberry Pi running Wheezy and having no problems at all (and being free of systemd malware ;) that looks like a bug of arecord. Debian Jessie &lt;a href=&#34;https://packages.debian.org/jessie/alsa-utils&#34;&gt;includes&lt;/a&gt; &lt;code&gt;alsa-utils&lt;/code&gt; of version &lt;code&gt;1.0.28&lt;/code&gt; and &lt;code&gt;arecord --version&lt;/code&gt; on my Raspbian (image &lt;code&gt;2016-05-27-raspbian-jessie.img&lt;/code&gt;) gives the same. Here is &lt;a href=&#34;http://superuser.com/questions/583826/recording-using-arecord-creates-thousands-of-files&#34;&gt;the report&lt;/a&gt; that version &lt;code&gt;1.0.27&lt;/code&gt; of Linux Arch also suffers from that. Debian Wheezy &lt;a href=&#34;https://packages.debian.org/wheezy/alsa-utils&#34;&gt;has&lt;/a&gt; alsa-utils &lt;code&gt;1.0.25&lt;/code&gt; and it&amp;rsquo;s free of this bug. So since the bug was introduced in either &lt;code&gt;1.0.26&lt;/code&gt; or &lt;code&gt;1.0.27&lt;/code&gt; version of &lt;code&gt;alsa-utils&lt;/code&gt;, downgrading it to a version below &lt;code&gt;1.0.26&lt;/code&gt; should normally help.&lt;/p&gt;
&lt;p&gt;Here is how to do that in Raspbian Jessie environment (correct the repo address according to your version):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Firstly we are going to add Wheezy&amp;rsquo;s repo to the system. Add &lt;code&gt;deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi&lt;/code&gt; line to the end of &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;Update the sources: &lt;code&gt;sudo apt-get update&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Check available versions of the package: &lt;code&gt;sudo aptitude versions alsa-utils&lt;/code&gt;. This should show an older version of &lt;code&gt;alsa-utils&lt;/code&gt; to become available.&lt;/li&gt;
&lt;li&gt;Install the older version (depeinding from what&amp;rsquo;s available): &lt;code&gt;sudo apt-get install alsa-utils=1.0.25-4&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now check arecord. For USB sound card detected as a device #1 this would be: &lt;code&gt;arecord -D plughw:1,0 -r 44100 -f cd -d 5 -vv ~/test.wav&lt;/code&gt;. Recording should stop in 5 seconds.&lt;/li&gt;
&lt;li&gt;Revert the changes made to &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; (just comment the newly added line) and update the sources again: &lt;code&gt;sudo apt-get update&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Have fun arecording!&lt;/p&gt;</description></item><item><title>Calibration of MAX31855 thermocouple converter</title><link>https://nagimov.me/post/max31855-thermocouple-to-digital-converter/</link><pubDate>Mon, 15 Aug 2016 17:55:00 -0800</pubDate><guid>https://nagimov.me/post/max31855-thermocouple-to-digital-converter/</guid><description>&lt;p&gt;&lt;img src=&#34;https://nagimov.me/images/MAX31855-K-Type-Thermocouple-Breakout-Board.png#floatright&#34; alt=&#34;width300px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I have recently spent some time playing with &lt;a href=&#34;https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX31855.html&#34;&gt;Maxim 31855 chips&lt;/a&gt;, in a need of precise and cheap K-type thermocouple logger. It is a cheap voltage amplifier with digital SPI interface, so it works perfectly well with Raspberry Pi or Arduino.&lt;/p&gt;
&lt;p&gt;There are many thermocouple amplifiers out there, and I am sure that most of them are properly calibrated for the temperature range around +/-50C, since even linear volt-to-degreeC conversion works fine in that range. It is only when it comes to extremely low/high temperatures, nonlinearities tend to mess up the readings.&lt;/p&gt;
&lt;p&gt;It is known that Maxim 31855 uses simple linear millivolts-to-degrees conversion through &lt;code&gt;0.041276&lt;/code&gt; factor (i.e. 1&amp;nbsp;millivolt junction potential is 0.04&amp;nbsp;degrees&amp;nbsp;C). That gives the way to reverse calculate the potential. We can then use more sophisticated &lt;a href=&#34;http://srdata.nist.gov/its90/download/type_k.tab&#34;&gt;NIST formulation&lt;/a&gt; to find the temperature difference between junctions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from math import exp
def nist_tc(tc, cj): # tc - thermocouple, cj - cold junction
tcV = (tc - cj) * 0.041276
cjV = \
-0.176004136860E-01 + \
0.389212049750E-01 * cj + \
0.185587700320E-04 * cj**2.0 + \
-0.994575928740E-07 * cj**3.0 + \
0.318409457190E-09 * cj**4.0 + \
-0.560728448890E-12 * cj**5.0 + \
0.560750590590E-15 * cj**6.0 + \
-0.320207200030E-18 * cj**7.0 + \
0.971511471520E-22 * cj**8.0 + \
-0.121047212750E-25 * cj**9.0 + \
0.118597600000E+00 * \
exp(-0.118343200000E-03 * (cj - 0.126968600000E+03)**2.0)
sumV = tcV + cjV
if tcV &amp;lt; 0:
b = [ 0.0000000E+00, 2.5173462E+01, \
-1.1662878E+00, -1.0833638E+00, \
-8.9773540E-01, -3.7342377E-01, \
-8.6632643E-02, -1.0450598E-02, \
-5.1920577E-04, 0.0000000E+00, \
]
elif tcV &amp;lt; 20.644:
b = [ 0.000000E+00, 2.508355E+01, \
7.860106E-02, -2.503131E-01, \
8.315270E-02, -1.228034E-02, \
9.804036E-04, -4.413030E-05, \
1.057734E-06, -1.052755E-08, \
]
elif tcV &amp;lt; 54.886:
b = [ -1.318058E+02, 4.830222E+01, \
-1.646031E+00, 5.464731E-02, \
-9.650715E-04, 8.802193E-06, \
-3.110810E-08, 0.000000E+00, \
0.000000E+00, 0.000000E+00, \
]
else:
print(&#39;voltage error&#39;)
return None
temp = 0
for index, element in enumerate(b):
temp += element * sumV**index
return temp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nice cheap SPI-interfaced breakout boards are &lt;a href=&#34;https://www.adafruit.com/product/269&#34;&gt;sold by Adafruit&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Amazon Fire TV 2nd Gen - Root &amp; OpenVPN</title><link>https://nagimov.me/post/fire-tv-2nd-gen-root-openvpn/</link><pubDate>Wed, 30 Mar 2016 19:35:32 -0800</pubDate><guid>https://nagimov.me/post/fire-tv-2nd-gen-root-openvpn/</guid><description>&lt;p&gt;&lt;strong&gt;My notes after spending half a day playing with my Fire TV.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nagimov.me/images/amazon-fire-tv.png#center&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;While Amazon Fire TV seems to be the best htpc solution to me, it still requires rooting and a bit of patching on its way to a decent media center. I&amp;rsquo;m also used to US streaming services (&lt;em&gt;Pandora&lt;/em&gt;, &lt;em&gt;Netflix&lt;/em&gt;, &lt;em&gt;Hulu&lt;/em&gt;, etc) which are only available through VPN, if you are outside of US. Rooting and setting up Kodi + OpenVPN is a way to go.&lt;/p&gt;
&lt;p&gt;Rooting is simple and straightforward, I followed &lt;a href=&#34;http://www.aftvnews.com/how-to-root-the-amazon-fire-tv-2/&#34;&gt;this guide&lt;/a&gt; and everything went smooth.&lt;/p&gt;
&lt;p&gt;Problems started with OpenVPN. Even though there are few tutorials out there (&lt;a href=&#34;https://www.reddit.com/r/fireTV/comments/2b4hlh/finally_got_vpn_working/&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://vpntips.com/fire-tv-vpn-install/&#34;&gt;there&lt;/a&gt;), I didn&amp;rsquo;t manage to install OpenVPN using the &lt;a href=&#34;http://apps.evozi.com/apk-downloader/?id=de.schaeuffelhut.android.openvpn.installer&#34;&gt;installer apk&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://jjjjango.blogspot.ca/2013/07/how-to-manually-install-openvpn-binary.html&#34;&gt;Another tutorial&lt;/a&gt; suggested to do manually everything what installer is supposed to do (i.e. unpack OpenVPN binary to &lt;code&gt;/system/xbin/&lt;/code&gt;). So I&amp;rsquo;ve done that and got &lt;code&gt;only position independent executables (PIE) are supported&lt;/code&gt; error when trying to start OpenVPN from adb console. Apparently, &lt;a href=&#34;http://forum.xda-developers.com/google-nexus-5/development/fix-bypassing-pie-security-check-t2797731&#34;&gt;there is a big issue&lt;/a&gt; with &lt;em&gt;position independent executables&lt;/em&gt; (whatever that means). The first fix is to find the OpenVPN binary compiled with PIE support (or compile it by yourself adding &lt;code&gt;&amp;quot;-fPIE -pie&amp;quot;&lt;/code&gt; linker option), but people are lazy, apparently. Another way to deal with that PIE issue is to patch the &lt;code&gt;linker&lt;/code&gt; binary located in &lt;code&gt;/system/bin/&lt;/code&gt; directory. I&amp;rsquo;ve tried a bunch of different versions of the &lt;code&gt;linker&lt;/code&gt; file, sometimes getting an unexpected behavior of Android (e.g. &lt;code&gt;application storage space is full&lt;/code&gt; error) or even screwing my Fire TV to the boot-loop. &lt;a href=&#34;http://forum.xda-developers.com/showpost.php?p=59497445&amp;amp;postcount=83&#34;&gt;This&lt;/a&gt; is the version of patched linker which worked great with my Fire TV.&lt;/p&gt;
&lt;p&gt;Just as a reminder, here is how you replace &lt;code&gt;linker&lt;/code&gt; file in &lt;code&gt;/system/bin/&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb push linker /sdcard/
adb shell
su
mount -o remount rw /system
mv /system/bin/linker /system/bin/linker.bak
cp /sdcard/linker /system/bin/
chmod 755 /system/bin/linker
mount -o remount ro /system
rm /sdcard/linker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Happy Kodiing!&lt;/p&gt;</description></item></channel></rss>